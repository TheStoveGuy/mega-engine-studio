<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprBlizzardCentuarIcon</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Height = ; (works by blocks)
Distance = ; (also by blocks)
Speed = ;
MyTile = ; (tile layer to shift)
AdditionalTile = ; (+ how many tiles, usually for animated tiles)
*/

Height = 1;
Distance = 1;
Speed = 1;
MyTile = 10;
AdditionalTile = 0;
    
Direction = sign(Distance);
Distance = abs(Distance);
image_yscale = Height;

Width = 0;

GetY = y;
YOffset = 0;

objects = ds_list_create();

init = 1;
alarm[0] = 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// delayed for water
for(i=0; i&lt;=image_xscale; i+=1;)
for(j=0; j&lt;=image_yscale; j+=1;)
{
    if collision_point(x+8+i*16,y+8+j*16,objWater,0,0)
    {
        a = collision_point(x+8+i*16,y+8+j*16,objWater,0,0).id;
        if !ds_list_find_index(objects,a)
        {
            ds_list_add(objects,a);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if init
{
    init = 0;
    
    Direction = sign(Distance);
    Distance = abs(Distance);
    image_yscale = Height;
    
    while !place_meeting(x,y,objStopScrolling)
    and !place_meeting(x,y,objRightScrolling)
    and !place_meeting(x,y,objLeftScrolling)
    and !place_meeting(x-16,y,objStopVerticleShift)
    and x &gt; 0
    {
        x -= 16;
    }
    Width = 0;
    
    while (!place_meeting(x+Width*16,y,objStopScrolling) || Width == 0)
    and !place_meeting(x+Width*16,y,objRightScrolling)
    and (!place_meeting(x+Width*16,y,objLeftScrolling) || Width == 0)
    and !place_meeting(x+Width*16,y,objStopVerticleShift)
    and x+Width*16 &lt; room_width
    {
        Width += 1;
    }
    image_xscale = Width;
    
    for(i=0;i&lt;=image_xscale;i+=1;)
    for(j=0;j&lt;=image_yscale;j+=1;)
    {
        if collision_point(x+8+i*16,y+8+j*16,objSolid,0,0)
        {
            a = collision_point(x+8+i*16,y+8+j*16,objSolid,0,0).id;
            if !ds_list_find_index(objects,a)
                ds_list_add(objects,a);
        }
        if collision_point(x+8+i*16,y+8+j*16,objTopSolid,0,0)
        {
            a = collision_point(x+8+i*16,y+8+j*16,objTopSolid,0,0).id;
            if !ds_list_find_index(objects,a)
                ds_list_add(objects,a);
        }
        if collision_point(x+8+i*16,y+8+j*16,objLadder,0,0)
        {
            a = collision_point(x+8+i*16,y+8+j*16,objLadder,0,0).id;
            if !ds_list_find_index(objects,a)
                ds_list_add(objects,a);
        }
        if collision_point(x+8+i*16,y+8+j*16,objSpike,0,0)
        {
            a = collision_point(x+8+i*16,y+8+j*16,objSpike,0,0).id;
            if !ds_list_find_index(objects,a)
                ds_list_add(objects,a);
        }
    }
}

if !global.frozen &amp;&amp; insideSection(x+8,y)
{
if Direction == 1
{
if y &lt; GetY+Distance*16
    {
    if place_meeting(x,y-1,objMegaman)
    or place_meeting(x,y+1,objMegaman)
        with objMegaman
        {
        if ground
        if (bbox_bottom &lt; other.bbox_bottom &amp;&amp; global.GravityDir &gt; 0)
        or (bbox_top &lt; other.bbox_top &amp;&amp; global.GravityDir &lt; 0)
            y += other.Speed;
        }
    y += Speed;
    YOffset += Speed;
    for(i=MyTile;i&lt;=MyTile+AdditionalTile;i+=1;)
        tile_layer_shift(i,0,Speed);
    for (i=0; ds_list_size(objects)&gt;i; i+=1;) {
        obj = ds_list_find_value(objects,i);
        if instance_exists(obj)
        with obj
            y += other.Speed;
        }
    }
else
    {
    Direction = -1;
    GetY += Distance*16;
    }
}
else
if Direction == -1
{
if y &gt; GetY-Distance*16
    {
    if place_meeting(x,y-1,objMegaman)
    or place_meeting(x,y+1,objMegaman)
        with objMegaman
        {
        if ground
        if (bbox_bottom &lt; other.bbox_bottom &amp;&amp; global.GravityDir &gt; 0)
        or (bbox_top &lt; other.bbox_top &amp;&amp; global.GravityDir &lt; 0)
            y -= other.Speed;
        }
    y -= Speed;
    YOffset -= Speed;
    for(i=MyTile;i&lt;=MyTile+AdditionalTile;i+=1;)
        tile_layer_shift(i,0,-Speed);
    for (i=0; ds_list_size(objects)&gt;i; i+=1;) {
        obj = ds_list_find_value(objects,i);
        if instance_exists(obj)
        with obj
            y -= other.Speed;
        }
    }
else
    {
    Direction = 1;
    GetY -= Distance*16;
    }
}
}
else
if !insideSection(x+8,y) and YOffset != 0
{
y = ystart;
for(i=MyTile;i&lt;=MyTile+AdditionalTile;i+=1;)
    tile_layer_shift(i,0,-YOffset);
for (i=0; ds_list_size(objects)&gt;i; i+=1;) {
    obj = ds_list_find_value(objects,i);
    instance_activate_object(obj);
    if instance_exists(obj)
    with obj
        y -= other.YOffset;
    }
YOffset = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
