<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprNiceSetter</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>prtAlwaysActive</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d = 1000000;
cpu_limit = 200; // maximum number of collision objects to place in any one frame
boss_door_n = 0; // number of boss doors in stack
boss_door_begin_event_n = 0; // number of boss doors to run begin events on

template_tile = tile_layer_find(d,x,y);

warnings = true;
display = false; // display progress bar

general_warning_message = "#To disable these warnings, add the following line to the creation code of the objNiceSetter:#warnings = false;"

if template_tile == -1 {
    // abort if template tile placed in the wrong position, with helpful error message
    if warnings show_message("Warning: the autotiler was not placed on top of a tile at depth " + string(d) + " and therefore cannot function." + general_warning_message)
    instance_destroy();
    exit;
}

tileset = tile_get_background(template_tile);
tileset_name = background_get_name(tileset)

// check that tile was placed correctly
if tile_get_left(template_tile) != 0 || tile_get_top(template_tile) != 0 || tile_get_width(template_tile) != background_get_width(tileset) || tile_get_height(template_tile) != background_get_height(tileset) {
    if warnings show_message("Warning: the autotiler was placed on a tile which does not cover the entire background resource, or extends off the tileset. Be sure to hold shift and drag to select the whole tileset from the pane in the room editor." + general_warning_message)
    instance_destroy();
    exit;
}

w = 16; // width of a tile
h = 16; // height of a tile

if x mod w || y mod h {
    if warnings show_message("Warning: the autotiler is not aligned to a " + string(w) + "x" + string(h) + " grid." + general_warning_message);
    instance_destroy();
    exit;
}

//list of objects that can be placed by the autotiler:
collision_object_n = 14;
collision_object[0] = objSolid;
collision_object[1] = objIce;
collision_object[2] = objTopSolid;
collision_object[3] = objStandSolid;
collision_object[4] = objLadder;
collision_object[5] = objSpike;
collision_object[6] = objWater;
collision_object[7] = objBossDoor;
collision_object[8] = objWaterFiller;
collision_object[9] = objSlopeR;
collision_object[10] = objSlopeL;
collision_object[11] = objSlopeRLong;
collision_object[12] = objSlopeLLong;
collision_object[13] = objSlopeExample;

// read tileset collision data from collision objects placed on template tile:
start_x = tile_get_x(template_tile);
start_y = tile_get_y(template_tile);

if start_x mod w || start_y mod h {
    if warnings show_message("Warning: the template tile that the autotiler is placed on is not aligned to a " + string(w) + "x" + string(h) + " grid." + general_warning_message);
    instance_destroy();
    exit;
}

max_x_ = round(tile_get_width(template_tile)/w)
max_y_ = round(tile_get_height(template_tile)/h)
for (x_=0;x_&lt; max_x_;x_+=1) {
    for (y_=0;y_&lt; max_y_;y_+=1) {
        template_object[x_,y_] = noone;
        for (t=0;t&lt;collision_object_n;t+=1) {
            // discover if a collision object of the given type is at the given position on the template tile:
            co = instance_position(start_x + x_*w + 1, start_y + y_*h + 1, collision_object[t]);
            if co != noone {
                // ignore object if it is not aligned and directly on top of the tile:
                if (co.x != start_x + x_*w) || (co.y != start_y + y_*h)
                    continue;
                // ignore if it's a subtype
                if co.object_index != collision_object[t]
                    continue;
                template_object[x_,y_] = collision_object[t]
                with co
                    instance_destroy();
                break; // don't check for any more tiles meeting at this position.
            }
        }
    }    
}

// print
str = ""
for (y_=0;y_&lt;max_y_;y_+=1) {
    for (x_=0;x_&lt;max_x_;x_+=1) {
        if template_object[x_,y_] != noone
            str += object_get_name(template_object[x_,y_]) + ","
        else str += "   ,"
    }
    str += "#"
}

// number of columns in room:
room_max_rx = room_width/w
// number of rows in room:
room_max_ry = room_height/h

// placement cursor position:
place_rx = 0;
place_ry = 0;

n_tiles_checked = 0; // number of tiles checked so far (for display stats)
max_tiles_checked = room_max_rx*room_max_ry // max number of tiles to check (for display checks)
placement_timer = 0; // number of frames setter has been placing tiles
complete = false; // has the tiler finished placing tiles?

// allocate placed collision object raster:
for (rx=0;rx&lt;=room_max_rx;rx+=1) {
    placed_object[rx,room_max_ry] = noone;
}
for (ry=0;ry&lt;=room_max_ry;ry+=1) {
    placed_object[room_max_rx,ry] = noone;
}

// notes: if this engine is ported to game maker studio, use tile_get_ids_at_depth to find tiles and replace the placed_object_array with a single-dimensional array containing just the tiles. Then in the step event, don't use find_tile; just iterate through the array returned by tile_get_ids_at_depth. This will be much faster, especially for sparse rooms.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !complete {
    // don't place additional tiles on first frame, to prevent lag.
    if placement_timer &gt; 0 {
        for (i=0;i&lt;cpu_limit;i+=1) {
            checkTile(place_rx*w + 1,place_ry*h + 1);
            n_tiles_checked += 1;
            place_rx += 1;
            // check room boundary conditions:
            if place_rx &gt; room_max_rx {
                place_ry += 1;
                place_rx = 0;
            }
            if place_ry &gt; room_max_ry {
                if complete
                    exit;
                popBossDoors();
                // some objects agglutinate
                with objSolid event_user(3)
                with objLadder event_user(3)
                with objSpike event_user(3)
                instance_destroy();
                complete = true;
            }
        }
    }
    placement_timer += 1;
    with objMegaman // deactivate objects that were just placed if they are outside of section
    {
        playerDeactivateObjects();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dx = view_xview[0];
dy = view_yview[0];

rec_x = 8;
rec_y = 8;
rec_w = 100;
rec_h = 8;

draw_set_alpha(1);
draw_set_color(c_blue);
draw_rectangle(dx + rec_x, dy + rec_y,dx + rec_x + rec_w*min(1,(n_tiles_checked / max_tiles_checked)), dy + rec_y + rec_h, false);
draw_set_color(c_white);
draw_rectangle(dx + rec_x, dy + rec_y, dx + rec_x + rec_w, dy + rec_y + rec_h, true)
draw_set_valign(fa_top);
draw_set_halign(fa_left);
draw_text(dx + rec_x + 2, dy + rec_y + 1, string(n_tiles_checked) + "/" + string(max_tiles_checked))
draw_text(dx + rec_x + rec_w + 2, dy + rec_y + 1, tileset_name)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
