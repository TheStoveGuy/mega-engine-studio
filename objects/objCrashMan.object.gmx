<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprCrashIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>sprCrashMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Creation code (all optional):
//infiniteCrashBombs = true; -  use this if you want Crash Man to use infinite Crash Bombs. only use this if you are particularly dickish.
event_inherited();

healthIndex = 1;

healthpointsStart = 28;
healthpoints = healthpointsStart;

pose = sprCrashIntro;
poseImgSpeed = 4/60;
contactDamage = 4;

ground = false;
attackTimer = 0;
beginAttackTimer = false;

// rather than using game maker's image offset features, this time round we're building a more accurate animation system.
imageTimer = 0;
imageTimerMax = 99;
// this is the minmum image_indexs of crash man for any given animation. imageNoMin is what the image_index is set to when plant man has finished an animation.
imageNoMin = 0;

attackTimerMax = 145;

phase = 0; 

jumpY = -6.5;
walkX = 1.3;

delay = 0;
hasFired = false;

infiniteCrashBombs = false;

//stores the weapon damage values
wpndmg[0] = 1; //Mega Buster
wpndmg[1] = 1; //Mega Buster Charge1
wpndmg[2] = 3; //Mega Buster Charge2
wpndmg[3] = 1; //Weapon Explosion
wpndmg[4] = 1; //HornetChaser
wpndmg[5] = 2; //JewelSatellite
wpndmg[6] = 0; //GrabBuster
wpndmg[7] = 6; //TripleBlade
wpndmg[8] = 3; //WheelCutter
wpndmg[9] = 2; //SlashClaw
wpndmg[10] = 3; //Sakugarne
wpndmg[11] = 2; //SuperArrow
wpndmg[12] = 12; //WireAdapter

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// crash man was made to showcase how simple a robot master can be created - anyone who knows code should be able to look at this and modify crash man to suit their purpose.
// i've gone into greater detail with comments in this robot master. if you were to modify any robot master for your stage - crash man is a good one to start with!

// leave this. this is needed.
event_inherited();

// all of crash man's events trigger when the game isn't frozen. he isn't weak to flash stopper, so no need to check whether that is used or not!
if global.frozen == false
{
    if isFight == true
    {
    // this sets up crash man's movement variables.
        image_speed = 0;
        
        checkGround();
        gravityCheckGround();
        // if crash man is walking, he turns around when he hits a wall, otherwise he doesn't.
        if sprite_index = sprCrashWalk
        {
            generalCollisionTurnaround();
            if place_meeting(x+28*sign(xspeed),y,objSolid)
            {
                if !place_meeting(x-28*sign(xspeed),y,objSolid)
                {
                    xspeed*=-1;
                    image_xscale*=-1;
                }
            }
        }
        else
        {
            generalCollision();
        }
        
        x += xspeed;
        y += yspeed;
        
        // resets the image timer if crash man ever changes poses
        if pose != sprite_index
        {
            pose = sprite_index;
            imageTimer = 0;
        }
        // these control various timers crash man uses - attackTimer and delay. 
        // attackTimer can trigger an attack to occur after a certain amount of ticks. (around 145)
        // Delay - Delay is useful to use to stop code from firing too quickly.
        if beginAttackTimer == true
            attackTimer += 1;
        if delay &gt; 0
            delay -= 1;
        // this is the animation system. don't touch this.    
        imageTimer += 1;
        if imageTimer &gt;= imageTimerMax &amp;&amp; image_index &lt; image_number-1
        {
            imageTimer = 0;
            image_index += 1;
        }
        if imageTimer &gt;= imageTimerMax &amp;&amp; image_index == image_number-1
        {
            imageTimer = 0;
            image_index = imageNoMin;
        }
        
        // this is crash man's AI - 
        // 0: walk until he hits a wall, turn around.
        // 1: jump when the fire button is pressed, or when he reaches a certain attack timer.
        // 2: fire when he reachs the apex of his jump. the aiming of the projectile is handled by the projetile itself.
        // 3: reset everything when he hits the ground.
        switch phase
        {
            case 0: // walk
                // crash man walk speed is dependant on what direction he is facing.
                xspeed = walkX*image_xscale;
                // this sets up the animation system. crash man changes animation frames every 8 ticks, and resets to the first frame of his animation.
                sprite_index = sprCrashWalk;
                imageNoMin = 0;
                imageTimerMax = 8;
                if instance_exists(target)
                    megax = target.x;
                
                // if the shoot button is pressed, or crash man reaches a certain timer, he changes to phase 1, jumping.
                if (global.keyShootPressed[target.player_id]) || (attackTimer &gt;= attackTimerMax)
                {
                    beginAttackTimer = true;
                    sprite_index = sprCrashJump;
                    phase = 1;
                    attackTimer = 0;
                // absolute returns a positive value, even if the input is a negative number.
                    randomiser = floor(abs(megax-x)/32)*0.5;
                    if randomiser &gt; 3 
                        randomiser = 3;
                    randomiser += irandom_range(0,2)*0.5;
                }
                break;
            case 1: // jump
                if ground == true &amp;&amp; delay == 0
                {
                    // delay is added to prevent this triggered before he leaves the ground. this shouldn't be needed, but might be if you do anything more complex.
                    delay = 4;
                    calibrateDirection();
                    yspeed = jumpY;
                    // crash man's jumping speed is chosen randomly, with the value the randomiser has found above.
                    xspeed = randomiser*image_xscale;
                }
                if ground == false &amp;&amp; delay == 0
                {
                    calibrateDirection();
                }
                // when crash man reaches the apex of his jump, he changes to phase 2  
                if ground == false &amp;&amp; yspeed &gt;= 0
                {
                    phase = 2;
                    imageNoMin = 2;
                    imageTimerMax = 8;
                    sprite_index = sprCrashFire;
                    image_index = 1;
                }
                break;
            case 2: // fire crash bomber
                calibrateDirection();
                // when crash man hits a certain animation frame, he fires the crash bomb. he only fires if a crash bomb is not in existance.
                if image_index == 2 &amp;&amp; hasFired == false
                {
                    if (!instance_exists(objCrashBomber) &amp;&amp; infiniteCrashBombs == false) || (infiniteCrashBombs == true)
                    {
                        cB = instance_create(x+(6*image_xscale),y+9,objCrashBomber);
                        cB.image_xscale = image_xscale;
                        hasFired = true;
                    }
                    else 
                        hasFired = true;
                    
                }
                
                // when crash man hits the ground, he resets completely.
                if ground == true
                {
                    imageTimer = 0;
                    attackTimer = 0;
                    phase = 0;
                    hasFired = false;
                    delay = 0;
                }
                break;
        }
    }
}
else
{
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
