<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprNPCKnightmanIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>objNPC</parentName>
  <maskName>maskNPC</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//creation code (technically all optional)
//name = "string here" (sets the name in their dialogue box)
//text = "string here" (sets the text in their dialogue box)

//behaviour = "wander" / "restlesss" / "patrol" / "nostop" (sets the balance of probabilities of walking/idle, when to turn around, etc.)
//jumps_pits =  true / false (jumps when at the edge of a pit if a safe landing is detected or avoids_pits is false)
//ignores_pits = true / false (always walks off the ledge into pits)
//avoids_pits = true / false (turns around when at the edge of a pit)
//only_jumps = true / false (only moves around by jumping. This is useful as a ton of robot masters don't have walking animations)

//idle_sprite = [sprite] (sets the sprite they use for their idle animation) (becomes the default of all of the other animations if the rest aren't set)
//idle_start = # (the starting frame of their idle animation)
//idle_end = # (the ending frame of their idle animation)
//idle_speed = # (the speed of the idle animation)

//talk_sprite = [sprite] (sets the sprite of their talking animation) (default is the same as the idle animation)
//talk_start = # (the starting frame of their talking animation)
//talk_end = # (the ending frame of their talking animation)
//talk_speed = # (the speed of the talk animation)

//move_speed = # (sets how fast they move around)
//walk_sprite = [sprite] (sets the sprite that's used for their walking animation) (default is the same as the idle animation)
//walk_start = # (the starting frame of their walking animation)
//walk_end = # (the ending frame of their walking animation)
//walk_speed = # (the speed of the walk animation)

//jump_speed = # (the speed they jump up with)
//jump_sprite = # (sets the sprite that's use for their jumping animation) (default is the same as the idle animation)
//jump_start = # (the only frame for their jump animation (can't have it animated))

name = 'Knight Man';

event_inherited();

//behaviours
behaviour = "wander";
avoids_pits = true;
     
jumps_pits = true;
ignores_pits = false;
avoids_pits = true;
move_speed = noone; //gets defaulted in step code on first frame
jump_speed = -4.8;

// animation:
idle_sprite = sprNPCKnightmanIdle;
talk_sprite = idle_sprite;
walk_sprite = sprNPCKnightmanWalk;
jump_sprite = sprNPCKnightmanJump;

walk_start = 0;
walk_end = sprite_get_number(walk_sprite) - walk_start;

walk_speed = idle_speed;
jump_start = 0;
only_jumps = false;

//private:
mode = 0;
mode_timer = 0;
mode_timer_end = 0;
standard_physics = false;
despawnRange = 700000;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
 
image_speed = 0;
 
var sec_left, sec_right;
sec_left = 0
sec_right = room_width;
 
if (!global.frozen &amp;&amp; !global.flashStopper &amp;&amp; !dead)
{
    // physics:
           
    checkGround();
    gravityCheckGround();
    if place_meeting(x,y+2,objSolid)
        ground = true;
   
    // select behaviour:
    mode_timer += 1;
    if mode_timer &gt; mode_timer_end &amp;&amp; ground {
        mode_timer = 0;
        if behaviour == "restless" {
            if mode == 0
                mode = 1
            else
                mode = 0;
            mode_timer_end = 15 + random(25) + random(170);
            if mode == 0 &amp;&amp; mode_timer_end &gt; 100
                mode_timer_end = 100;
            image_xscale = irandom(1)*2 - 1
        } else if behaviour == "wander" {
            if mode == 0
                mode = 1
            else
                mode = 0;
            if (mode == 0)
                mode_timer_end = 100 + random(2000);
            else
                mode_timer_end = 100 + random(300);
            image_xscale = irandom(1)*2 - 1
        } else if behaviour == "patrol" {
            if mode == 0
                mode = 1
            else
                mode = 0;
            if (mode == 0)
                mode_timer_end = 20 + random(150);
            else
                mode_timer_end = 1000 + random(2000);
            if random(2) &gt; 1.4
                image_xscale = irandom(1)*2 - 1
        } else if behaviour == "nostop" {
            mode = 1; // never stops; only turns around at obstacles
        }
    }
       
    switch mode {
    case 0: // idle:
        xspeed = 0;
        sprite_index = idle_sprite
        animationLoop(idle_start,idle_end,idle_speed)
           
        if face_player
            calibrateDirection();
        break;
    case 1: // walk
        if !only_jumps {
            xspeed = image_xscale * move_speed;
            sprite_index = walk_sprite
            animationLoop(walk_start,walk_end,walk_speed)
        } else {
            // hops around; in-between, stands still
            sprite_index = idle_sprite;
            animationLoop(idle_start,idle_end,idle_speed)
            if !ground
                xspeed = image_xscale * move_speed;
            if ground
                xspeed = 0;
        }
        if !ground {
            // jumping animation
            sprite_index = jump_sprite;
            image_index = jump_start;  
        }
        if ground &amp;&amp; place_meeting(x,y+2,objSolid) {
            // note -- moving platforms and jumpthrough platforms not resolved.
            if instance_exists(target) {
                sec_left = global.sectionLeft
                sec_right = global.sectionRight
            }
            // reason about terrain
            if (x + xspeed * 7 &lt;= sec_left) || (x + xspeed * 7 &gt;= sec_right) {
                // about to go off edge of screen
                xspeed = 0;
                mode = 0;
                if ground
                    image_xscale *= -1;
            } else if place_meeting(x+xspeed*18,y,objSolid) {
                // see if it is possible to jump
                // wall in front
                doJump = false;
                for (i=0;i&lt;=48;i+=8) {
                    if !place_meeting(x + xspeed*18,y - i,objSolid)
                        doJump = true;
                }
                if doJump {
                    yspeed = -abs(jump_speed);
                } else {
                    image_xscale *= -1;
                    // stop if we're close to stopping
                    if abs (mode_timer_end - mode_timer) &lt; 50
                        mode_timer += 50;
                }
            } else if !place_meeting(x + sprite_width/2.2,y + 24,objSolid) {
                // pitfall detected
                if jumps_pits {
                    if !avoids_pits || place_meeting(x + 56*xspeed,y+64,objSolid) || place_meeting(x + 43*xspeed,y+36,objSolid) || place_meeting(x + 32*xspeed,y+8,objSolid) || ignores_pits  {
                        // pit; jump over it
                        yspeed = -abs(jump_speed);
                    } else // turn around at pit:
                        image_xscale *= -1
                } else if avoids_pits &amp;&amp; !ignores_pits
                    image_xscale *= -1;
            }
        }
       
        // hopping logic:
        if ground &amp;&amp; yspeed &gt;= 0 &amp;&amp; only_jumps &amp;&amp; place_meeting(x + 32*xspeed, y + 8, objSolid) {
            if mode_timer mod 140 == 30
                yspeed = -abs(jump_speed)
        }
        break;
    }
   
    generalCollision();
       
    x += xspeed;
    y += yspeed;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// start dialogue

sprite_index = talk_sprite
image_speed = talk_speed
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// end dialogue

with objMegaman {
    canMove = 1;
    canStep = true;
    global.frozen = 0;
}

active = false;
image_xscale = _prev_direction;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//creation code setup stuff
if (string_length(name) &gt; 27)
{
    name = string_copy(name, 0, 27);
}

//make custom idle sprites the default sprites for unset sprites
if (idle_sprite != sprNPCKnightmanIdle)
{
    if (talk_sprite == sprNPCKnightmanIdle)
    {
        talk_sprite = idle_sprite;
    }
    if (walk_sprite == sprNPCKnightmanWalk)
    {
        walk_sprite = idle_sprite;
    }
    if (jump_sprite == sprNPCKnightmanJump)
    {
        jump_sprite = idle_sprite;
    }
}

if (move_speed == noone)
{
    if (behaviour == "wander")
    {
        move_speed = 0.4;
    }
    else
    {
        move_speed = 1.05;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if sprite_index == sprNPCKnightmanIdle { exit; }

drawSelf();

with (target)
{
    if (place_meeting(x + image_xscale*other.talk_distance,y,other)) &amp;&amp; ground &amp;&amp; canMove
    {
        with (other)
        {
            draw_sprite(sprPressUp,0,bbox_get_xcenter(),bbox_top-12);
            exit;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
