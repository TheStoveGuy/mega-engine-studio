<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprSplashIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtBoss</parentName>
  <maskName>sprSplashMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

healthIndex = 1;

healthpointsStart = 28;
healthpoints = healthpointsStart;

pose = sprSplashIntro;
poseImgSpeed = 10/60;
contactDamage = 4;

ground = false;
attackTimer = 10;
attackTimerMax = 20;
canInitShoot = true;
phase = 0; 

// setup initial animation direction. this direction overrights the image_xscale in certain circumstances.
if instance_exists(target)
        {
            if x &gt; target.x
                detectAnimation  = -1;
            else
                detectAnimation  = 1;
        }

xspeed = 0;
hitWall = false;
redetectWall = 0;
detectRoof = 0;
shotsFired = 0;

starty = y;

//sin x movement variables:
//resetX=x;
//cDistanceX=0;
//cAngleX=degtorad(90);
//addAngleX=0;
//readableXAngle=0;

//cos y movement variables:
cDistanceY=4;
cAngleY=0;
addAngleY=0;

//fish spawner
distanceYToFish = 32;
fishCreated = 0;
fishYDistance = 20;
fishDirection = image_xscale;
fishToggle = false;
fishSpawnX = 0;
fishSpawnY = 0;

//stores the weapon damage values
wpndmg[0] = 2; //Mega Buster
wpndmg[1] = 2; //Mega Buster Charge1
wpndmg[2] = 4; //Mega Buster Charge2
wpndmg[3] = 2; //Weapon Explosion
wpndmg[4] = 4; //HornetChaser
wpndmg[5] = 1; //JewelSatellite
wpndmg[6] = 1; //GrabBuster
wpndmg[7] = 1; //TripleBlade
wpndmg[8] = 1; //WheelCutter
wpndmg[9] = 1; //SlashClaw
wpndmg[10] = 3; //Sakugarne
wpndmg[11] = 4; //SuperArrow
wpndmg[12] = 6; //WireAdapter
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>phase=3;
playSFX(sfxSplashSing);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gives a delay for when splash woman starts moving.</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if global.frozen == false
{
    
    cAngleY += addAngleY;
    // on certain animations, splash woman bobs up and down.
    if sprite_index == sprSplashIntro or sprite_index == sprSplashLaserTrident or sprite_index == sprSplashIdle
        addAngleY = 0.05;
        
        
    if !sprite_index == sprSplashLaserTrident &amp;&amp; cDistanceY &gt; 4        
        cDistanceY-=0.25;
        
    if sprite_index == sprSplashLaserTrident &amp;&amp; cDistanceY &lt; 8 
        cDistanceY+=0.25;
    
    if instance_exists(target) &amp;&amp; isFight == false
        {
            if x &gt; target.x
                detectAnimation  = -1;
            else
                detectAnimation  = 1;
        }    
            
    if isFight == true
    {
        generalCollision();
        x += xspeed;
        y += yspeed;
        attackTimer += 1;
        
        // this value is used to override the image_xscale occasionally.
        if xspeed &gt; 0
            detectAnimation = 1;
        else if xspeed &lt; 0
            detectAnimation = -1;
        else
            detectAnimation = image_xscale;
        
        
        switch phase
        {
            case 0: //Idle (standing still)
                checkGround();
                if y &lt; starty
                    gravityCheckGroundExt(0.35);
                else
                    yspeed = 0;
                attackTimerMax = 35;
                xspeed = 0;
                sprite_index = sprSplashIdle;
                image_index += 0.15;
                if attackTimer == attackTimerMax
                    phase = 1;
            break;
            case 1: // determine move distnace for next phase and generate the first detector
                SWD = instance_create(x,y,objSplashWallDetector);
                SWD.image_xscale = image_xscale;
                alarm[7] = 12;
                phase = 2;
            break;
            
            // phase 2 is basically skipped to allow the alarm to happen. the alarm also triggers splashwoman's sing effect.
            
            case 3: // begin sing / go up
            checkGroundExt(-1);
            image_index += 0.10;
            sprite_index = sprSplashSing;
            // this generates the splash wall dectector, a detector that allows slash woman to turn around when near walls, rather than when actually hitting them.
            if instance_exists(objSplashWallDetector)
            {
            objSplashWallDetector.y = y;
            redetectWall +=1;
            // occasionally we destroy the detector and remake it. we do this if she's either in a different direction to the detector or the counter has reset.
            if objSplashWallDetector.image_xscale != image_xscale or redetectWall &gt;= 3
                {
                with objSplashWallDetector
                    instance_destroy(); 
                SWD = instance_create(x,y,objSplashWallDetector);
                SWD.image_xscale = image_xscale;
                redetectWall = 0;
                }
            
            // if speed is lower than 3, and splash is not against wall, speed up.
            if abs(xspeed) &lt; 3 &amp;&amp; hitWall == false
                xspeed += image_xscale/3;
            // if any of the following are true, splash woman is near to, or has hit a wall and needs to turn around.
            if 
            (xspeed &gt; 0 &amp;&amp; objSplashWallDetector.x &gt; view_xview + (view_wview * 0.5) &amp;&amp; x &gt;= objSplashWallDetector &amp;&amp; objSplashWallDetector.hitWall == true) 
            or
            (xspeed &lt; 0 &amp;&amp; objSplashWallDetector.x &lt;= view_xview + (view_wview * 0.5) &amp;&amp; x &lt;= objSplashWallDetector &amp;&amp; objSplashWallDetector.hitWall == true)
            or 
            (place_meeting(x,y,objSplashWallDetector) &amp;&amp; objSplashWallDetector.hitWall == true &amp;&amp; image_xscale == objSplashWallDetector.image_xscale)
                {
                hitWall = true;
                }
            // if the above is true, splash woman slows down and eventually turns around.    
            if hitWall == true   
                xspeed -= image_xscale/4;
            // deactivating the above when she's no longer near a wall.    
            if !place_meeting(x+(8*image_xscale),y,objSplashWallDetector)    
                hitWall = false;
             } 
             
             // if splash woman has turned around, then she ... well, turns around.
             if image_xscale == -1 &amp;&amp; xspeed &gt; 0 &amp;&amp; hitWall == false
                image_xscale = 1;
             else if image_xscale == 1 &amp;&amp; xspeed &lt; 0 &amp;&amp; hitWall == false
                image_xscale = -1;
                    
             yspeed = -0.45;
             
             // generate fishies
             if y &lt;= (view_yview+(view_hview)) - ((distanceYToFish * fishCreated)) - 64 &amp;&amp; fishCreated &lt; 3 &amp;&amp; hitWall == true
             {
                
                 var i;
                 for (i = 0; i &lt; 3; i += 1) 
                 {
                 if fishDirection = -1
                    fishSpawnX = view_xview+view_wview + (view_wview/4) + (32*(i));
                 else
                    fishSpawnX = view_xview - (view_wview/4) - (32*(i));
                 fishSpawnY = (view_yview+view_hview) - 32 - ((distanceYToFish * (fishCreated+1)) + (fishYDistance * (i-1)));
                 // this long line of code does the following: it finds the edge of the x screen.. and the bottom of the y screen, and modifies where the fish are created occordingly.
                 fish = instance_create(fishSpawnX,fishSpawnY,objSplashFlounder);
                 fish.image_xscale = fishDirection;
                 fish.respawn = false;
                 }  
                 
                 fishCreated += 1;
                 fishDirection = fishDirection * -1;
             }
             
            if ground == true
                detectRoof += 1;
            else
                detectRoof = 0;
            
            attackTimer = 0;    
                    
            if detectRoof &gt;= 16
            {
                attackTimer = 0;
                attackTimerMax = 30;
                
                sprite_index = sprSplashIdle;
                phase = 4;
                
            }
             
            break;
            case 4: // begin laser trident 
            detectRoof = 0;
            image_index += 0.15;
            attackTimerMax = 30;
            
            if xspeed &gt; 0
                xspeed -= 0.10;
            if xspeed &lt; 0
                xspeed += 0.10
            
            if attackTimer &gt;= attackTimerMax
                {
                sprite_index = sprSplashLaserTrident;
                image_index = 0;
                phase = 5;
                }  
            break;  
            
            case 5: // laser trident 
            image_index += 0.25;
            // follow mega man
            if instance_exists(target)
            {
             if x &gt; target.x
                xspeed -= 0.15;
            else if x &lt; target.x
                xspeed += 0.15;
            }    
            if xspeed &gt; 3
                xspeed = 3;
            if xspeed &lt; -3
                xspeed = -3;
            // turn around
            if xspeed &gt; 0
                image_xscale = 1;
            else
                image_xscale = -1;
            // fire laser trident
            if image_index == 6
                {
                lT = instance_create(x+(4*image_xscale),y+10,objSplashTrident);
                playSFX(sfxLaserTrident);
                shotsFired += 1;
                } 
            // reset animation to original position + 1      
            if image_index &gt;= 9 &amp;&amp; shotsFired &lt; 6
                image_index = 2;
                
            // divebomb!    
            if image_index &gt;= 9 &amp;&amp; shotsFired &gt;= 6
                {
                sprite_index = sprSplashDiveBomb;
                image_index = 0;
                phase = 6;
                }     
            
            break; 
            case 6: // divebomb 
            xspeed = 0;
            checkGroundExt(1);
            if image_index &lt; 6
                image_index += 0.20;
            if image_index &gt;= 4 &amp;&amp; ground == false
                yspeed = 4;
            if ground == true
                {
                yspeed = -2
                attackTimer = 0;
                sprite_index = sprSplashRebound;
                image_index = 0;
                phase = 7;
                }
            break;
            case 7: // divebomb finish
            attackTimerMax = 8;
            gravityCheckGroundExt(0.35);
            if attackTimer == attackTimerMax
                {
                attackTimer = 0;
                sprite_index = sprSplashIdle;
                image_index = 0;
                phase = 0;
                fishCreated = 0;
                shotsFired = 0;
                }
            break;
        }
        // if splash is singing, create note for her to sing.
        if sprite_index = sprSplashSing &amp;&amp; !instance_exists(objSplashNote)
            instance_create(x+(16*image_xscale),y-23,objSplashNote);
            
        // change postion of note depending on what frame its on.    
        if instance_exists(objSplashNote)
        {    
            objSplashNote.image_index += 0.10;
            if objSplashNote.image_index &gt; 4
                objSplashNote.image_index = 0;
            
            if objSplashNote.image_index &lt; 2
            {
                objSplashNote.x = x+(16*detectAnimation);
                objSplashNote.y = y-23;
            }
            else
            {
                objSplashNote.x = x+(24*detectAnimation)
                objSplashNote.y = y-16
            }
            
        }
                
        //Face the player if not doing anything.
        if (instance_exists(target) &amp;&amp; phase == 0) or (instance_exists(target) &amp;&amp; phase == 4)
        {
            if x &gt; target.x
            {
                image_xscale = -1;
                fishDirection = detectAnimation;
            }
            else
            {
                image_xscale = 1;
                fishDirection = detectAnimation;
            }
        }
    }

}
else
{
    image_speed = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if isIntro == true
and IntroType == 1
    {
    draw_set_alpha(IntroFade);
    draw_set_color(c_black);
    draw_rectangle(view_xview,view_yview,view_xview+view_wview,view_yview+view_hview,0);
    draw_set_alpha(1);
    }

if drawBoss == true &amp;&amp; detectAnimation == image_xscale
// most of the time splash woman's y position is based off a cosine wave, and her image_xscale is normal.
    draw_sprite_ext(sprite_index, image_index, round(x), round(y+sin(cAngleY)*cDistanceY), image_xscale, image_yscale, image_angle, image_blend, image_alpha);
// however, if for a split second, we want splash woman's image_xscale to be different to what it's supposed to be, in this case, the following is ran instead.
if drawBoss == true &amp;&amp; detectAnimation != image_xscale
    draw_sprite_ext(sprite_index, image_index, round(x), round(y+sin(cAngleY)*cDistanceY), image_xscale*-1, image_yscale, image_angle, image_blend, image_alpha);
    
if drawHitSpark == true
    draw_sprite_ext(sprHitspark, 0, sprite_get_xcenter(), round(y+sin(cAngleY)*cDistanceY)-8, 1, 1, 0, c_white, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
